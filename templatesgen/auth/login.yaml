version: "1.0"
method: POST
path: "/auth/login"
description: "Autenticar usuario (compatible PostgreSQL y MySQL)"

auth:
  required: false  # Este endpoint NO requiere token JWT para acceder
                   # (es el login, así que aún no tienes token)
params:
  body:            # Parámetros vienen en el body del request (JSON)
    - name: "username"
      type: "string"
      required: true
      validation:
        min_length: 3   # Validación: mínimo 3 caracteres
        max_length: 50  # Validación: máximo 50 caracteres
    
    - name: "password"
      type: "string"
      required: true
      validation:
        min_length: 6   # Validación: mínimo 6 caracteres
        max_length: 100 # Validación: máximo 100 caracteres

commands:
  # 1. Buscar usuario por username
  - type: query               # Tipo: consulta SQL
    sql: |                    # SQL multi-línea
      SELECT
        u.id, u.username, u.nombre, u.apellido, u.email,
        u.password_hash, u.activo, u.empresa_id,
        COALESCE(STRING_AGG(DISTINCT p.codigo, ',' ORDER BY p.codigo), '') as permissions
      FROM usuarios u
      LEFT JOIN user_roles ur ON u.id = ur.user_id
      LEFT JOIN roles r ON ur.role_id = r.id
      LEFT JOIN role_permissions rp ON r.id = rp.role_id
      LEFT JOIN permissions p ON rp.permission_id = p.id
      WHERE u.username = :username AND u.activo = true
      GROUP BY u.id
    returns: "single"          # Espera un solo resultado del select
    on_result:
      if_not_found:            # Manejo de error
        action: "abort"        # Detiene ejecución
        message: "Usuario no encontrado o inactivo"
    # Agregar transform_params para pasar resultados al siguiente comando
    transform_params:              # Pasa valores al siguiente comando
      id: "id"                        # Toma el 'id' del resultado y lo pasa como 'id'
      password_hash: "password_hash"  # Toma 'password_hash' y lo pasa igual
  
  # 2. Validar contraseña - los parámetros vienen del transform_params anterior
  - type: custom                     # Tipo: handler personalizado
    handler: "validate_password"     # Llama a esta función en Go
  
  # 3. Actualizar último login
  #- type: exec
  #  sql: "UPDATE usuarios SET ultimo_login = NOW() WHERE id = :id"

response:
  success:
    code: 200                      # HTTP status code
    message: "Login exitoso"       # Mensaje amigable
  
  map:
    user_id: "id"                  # Renombra 'id' del SQL a 'user_id' en response
    username: "username"           # Mantiene igual
    nombre: "nombre"
    apellido: "apellido"
    email: "email"
    empresa_id: "empresa_id"
    permissions: "permissions"      #temporal para DEBUG

  dynamic_fields:                   # Campos dinámicos (generados en tiempo de ejecución)
    - name: "token"                 # Nombre del campo en la respuesta
      source: "jwt"                 # Fuente: generador de JWT
      claims:                       # Datos para incluir en el token
        user_id: "id"               # user_id = valor de campo 'id' del resultado
        username: "username"
        nombre: "nombre"
        apellido: "apellido"
        empresa_id: "empresa_id"
        permissions: "permissions"
      expires_in: "24h"             # Tiempo de expiración del token
    
    - name: "token_type"            # Campo estático    
      value: "Bearer"               # Valor fijo
    
    - name: "expires_in"            # Campo estático
      value: 86400                  # 24 horas en segundos

cache:
  enabled: false

audit:
  enabled: true                     # Registrar esta acción en logs de auditoría
  log_params: true                  # Registrar los parámetros recibidos
  sensitive_fields: ["password"]    # Campos sensibles (enmascarar en logs)
  exclude_params: ["password"]      # Excluir completamente del log
